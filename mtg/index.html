<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumpstart Tools — jamiekrueger.dev</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Open+Sans:wght@400;700&family=Barlow+Semi+Condensed:wght@600;700&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            background: #e8e8e8;
            color: #3b2a1a;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        /* ===== Nav Bar ===== */
        .nav {
            background: linear-gradient(180deg, #5c3d2e 0%, #4a3020 100%);
            border-bottom: 3px solid;
            border-color: #3a2214;
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            flex-shrink: 0;
        }

        .nav a {
            color: #f0ead4;
            text-decoration: none;
            font-size: 0.75rem;
            transition: color 0.15s ease;
        }

        .nav a:hover {
            color: #fff;
        }

        .nav h1 {
            color: #f0ead4;
            font-size: 0.75rem;
            flex: 1;
        }

        .hidden { display: none !important; }

        /* ===== App Layout ===== */
        .app {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background: #ddd8cc;
            padding: 1.5rem;
            gap: 1rem;
        }

        .card-columns {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            justify-content: center;
            align-items: flex-start;
        }

        .card-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        /* ===== Shared Theme Name Input ===== */
        .theme-name-shared {
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-weight: 700;
            font-size: 1.5rem;
            text-transform: uppercase;
            text-align: center;
            color: #3b2a1a;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            padding: 0.2rem 1rem;
            width: 100%;
            max-width: 500px;
            transition: border-color 0.15s ease;
        }

        .theme-name-shared:hover {
            border-bottom-color: #c0b8a8;
        }

        .theme-name-shared:focus {
            outline: none;
            border-bottom-color: #5c3d2e;
        }

        .theme-name-shared::placeholder {
            color: #b0a898;
        }

        /* ===== Packing Edit Card ===== */
        .packing-edit-card {
            height: min(520px, 70vh);
            aspect-ratio: 745 / 1040;
            max-width: 100%;
            background: #000;
            padding: 4.3%;
            box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.35);
            border-radius: 4.8%;
            overflow: hidden;
        }

        .packing-edit-inner {
            background: #fff;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 10px 10px 8px;
            border-radius: 2%;
        }

        .packing-edit-decklist {
            flex: 1;
            border: none;
            resize: none;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.8rem;
            line-height: 1.7;
            color: #43484f;
            width: 100%;
            padding: 4px 0;
        }

        .packing-edit-decklist:focus {
            outline: none;
        }

        .packing-edit-decklist::placeholder {
            color: #bbb;
        }

        .packing-edit-btn {
            margin-top: auto;
            width: 100%;
            display: block;
            text-align: center;
        }

        /* ===== Packing View (after generate) ===== */
        .packing-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

        .packing-view .output-canvas {
            height: min(520px, 70vh);
            width: auto;
            box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.35);
            border-radius: 4.8%;
        }

        .card-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
        }

        /* ===== Card Slot (theme card interactive area) ===== */
        .card-slot {
            aspect-ratio: 745 / 1040;
            background: #000;
            padding: 4.3%;
            box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.35);
            height: min(520px, 70vh);
            max-width: 100%;
            border-radius: 4.8%;
            overflow: hidden;
        }

        .card-slot-inner {
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        .upload-zone {
            position: absolute;
            inset: 0;
            background: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .upload-zone:hover,
        .upload-zone.drag-over {
            background: #f5f5f5;
        }

        .upload-zone .upload-label {
            font-size: 0.55rem;
            color: #6e4a3a;
            text-align: center;
            line-height: 1.8;
            pointer-events: none;
        }

        .upload-zone .upload-icon {
            font-size: 2rem;
            color: #6e4a3a;
            pointer-events: none;
        }

        .upload-zone input[type="file"] {
            display: none;
        }

        #crop-area {
            position: absolute;
            inset: 0;
        }

        .crop-viewport {
            position: absolute;
            inset: 0;
            overflow: hidden;
            cursor: grab;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .crop-viewport:active {
            cursor: grabbing;
        }

        .crop-viewport img {
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
            pointer-events: none;
            transform-origin: 0 0;
        }

        /* ===== Live Theme Overlay ===== */
        .theme-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            /* bar (2/13) + gradient (2/13) of inner card */
            height: calc(4 / 13 * 100%);
            pointer-events: none;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }

        .theme-overlay-name {
            color: #ffffff;
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
            overflow: hidden;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.55);
            height: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 1rem;
        }

        .theme-overlay-gradient {
            background: linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.45) 0%,
                rgba(0, 0, 0, 0.85) 100%
            );
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            flex: 1;
            padding: 0.6rem 1rem 0.75rem;
        }
        .theme-overlay.no-name .theme-overlay-gradient {
            background: linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.85) 100%
            );
        }

        .theme-overlay-colors {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .theme-overlay-colors img {
            width: 26px;
            height: 26px;
        }

        /* ===== Card Controls (below theme card) ===== */
        .card-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0.25rem;
            width: 100%;
        }

        .card-controls label {
            font-size: 0.55rem;
            margin-bottom: 0;
            white-space: nowrap;
        }

        .zoom-slider {
            flex: 1;
            accent-color: #5c3d2e;
        }

        .change-image-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 0.45rem;
            padding: 0.4rem 0.75rem;
            color: #f0ead4;
            background: linear-gradient(180deg, #5c3d2e 0%, #4a3020 100%);
            border: 2px solid;
            border-color: #6e4a3a #3a2214 #3a2214 #6e4a3a;
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        .change-image-btn:hover {
            transform: translateY(-1px);
        }

        /* ===== Color Identity Picker ===== */
        .color-picker-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        .color-picker-label {
            font-size: 0.55rem;
            color: #4a3020;
        }

        .color-picker {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-toggle {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 3px solid #3a2214;
            background: #f0ead4;
            cursor: pointer;
            padding: 6px;
            transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
            opacity: 0.35;
            filter: grayscale(1);
        }

        .color-toggle img {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .color-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 2px 4px 0 rgba(0, 0, 0, 0.3);
        }

        .color-toggle.active {
            opacity: 1;
            filter: grayscale(0);
            border-color: #5c3d2e;
            box-shadow: 0 0 0 2px #f0ead4, 0 0 0 4px #5c3d2e;
        }

        /* ===== Button ===== */
        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.6rem;
            color: #f0ead4;
            background: linear-gradient(180deg, #5c3d2e 0%, #4a3020 100%);
            border: 3px solid;
            border-color: #6e4a3a #3a2214 #3a2214 #6e4a3a;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.35);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 2px 4px 0 rgba(0, 0, 0, 0.4);
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 1px 1px 0 rgba(0, 0, 0, 0.35);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-download {
            text-decoration: none;
        }

        /* ===== Download Row ===== */
        .download-row {
            margin-top: 0.5rem;
        }

        /* ===== Status Area ===== */
        .status {
            margin-top: 0.75rem;
            font-size: 0.5rem;
            line-height: 1.8;
            min-height: 1.5rem;
            text-align: center;
            flex-shrink: 0;
        }

        .status--error {
            color: #c04040;
        }

        .status--warning {
            color: #a07020;
        }

        .status--info {
            color: #4a3020;
        }

        /* ===== Responsive: Mobile ===== */
        @media (max-width: 768px) {
            html, body {
                overflow: auto;
            }

            .nav {
                padding: 0.75rem 1rem;
                gap: 1rem;
            }

            .nav a, .nav h1 {
                font-size: 0.55rem;
            }

            .app {
                padding: 1rem;
                justify-content: flex-start;
            }

            .card-columns {
                width: 100%;
                gap: 1.5rem;
            }

            .card-column {
                width: 100%;
                max-width: 400px;
            }

            .packing-edit-card,
            .card-slot {
                height: auto;
                width: 100%;
            }

            .packing-view .output-canvas {
                width: 100%;
                height: auto;
            }

            .packing-edit-decklist {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <a href="/">&lt; Home</a>
        <h1>Jumpstart Tools</h1>
    </nav>

    <main class="app">
        <input
            id="theme-name"
            class="theme-name-shared"
            type="text"
            placeholder="THEME NAME"
            spellcheck="false"
            autocomplete="off"
        >
        <div class="card-columns">

            <!-- Packing List -->
            <div class="card-column">
                <div class="packing-edit-card" id="packing-edit">
                    <div class="packing-edit-inner">
                        <textarea
                            id="decklist"
                            class="packing-edit-decklist"
                            placeholder="Paste a decklist, one card per line.&#10;e.g.&#10;1x Lightning Bolt&#10;2 Counterspell&#10;Llanowar Elves&#10;4 Forest"
                            spellcheck="false"
                        ></textarea>
                        <button id="generate-btn" class="btn packing-edit-btn" type="button">Generate</button>
                    </div>
                </div>
                <div id="packing-view" class="packing-view hidden">
                    <canvas id="packing-canvas" class="output-canvas" width="745" height="1040"></canvas>
                    <div class="card-actions">
                        <button id="packing-edit-btn" class="btn" type="button">Edit</button>
                        <a id="packing-download" class="btn btn-download" download="packing-list.png">Download PNG</a>
                    </div>
                </div>
            </div>

            <!-- Theme Card -->
            <div class="card-column">
                <div class="card-slot" id="theme-slot">
                    <div class="card-slot-inner">
                        <div id="upload-zone" class="upload-zone">
                            <span class="upload-icon">&#x1F5BC;</span>
                            <span class="upload-label">Drop image here<br>or click to upload</span>
                            <input id="file-input" type="file" accept="image/*">
                        </div>
                        <div id="crop-area" class="hidden">
                            <div id="crop-viewport" class="crop-viewport">
                                <img id="crop-img" alt="">
                            </div>
                        </div>
                        <div class="theme-overlay hidden" id="theme-overlay">
                            <div class="theme-overlay-name" id="theme-overlay-name"></div>
                            <div class="theme-overlay-gradient">
                                <div class="theme-overlay-colors" id="theme-overlay-colors"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-controls hidden" id="theme-controls">
                    <label for="zoom-slider">Zoom:</label>
                    <input id="zoom-slider" class="zoom-slider" type="range" min="0" max="100" value="0">
                    <button id="change-image-btn" class="change-image-btn" type="button">Change Image</button>
                </div>
                <div class="color-picker-section hidden">
                    <label class="color-picker-label">Color identity:</label>
                    <div class="color-picker">
                        <button class="color-toggle" data-color="W" type="button" title="White">
                            <img src="/mtg/symbols/W.svg" alt="White">
                        </button>
                        <button class="color-toggle" data-color="U" type="button" title="Blue">
                            <img src="/mtg/symbols/U.svg" alt="Blue">
                        </button>
                        <button class="color-toggle" data-color="B" type="button" title="Black">
                            <img src="/mtg/symbols/B.svg" alt="Black">
                        </button>
                        <button class="color-toggle" data-color="R" type="button" title="Red">
                            <img src="/mtg/symbols/R.svg" alt="Red">
                        </button>
                        <button class="color-toggle" data-color="G" type="button" title="Green">
                            <img src="/mtg/symbols/G.svg" alt="Green">
                        </button>
                    </div>
                </div>
                <div class="download-row hidden" id="theme-download-row">
                    <a id="theme-download" class="btn btn-download" download="theme-card.png">Download PNG</a>
                </div>
                <canvas id="theme-canvas" class="hidden" width="745" height="1040"></canvas>
            </div>

        </div>
        <div id="status" class="status" aria-live="polite"></div>
    </main>

    <script>
        /* ===== Constants ===== */
        const TYPE_PRIORITY = [
            'Creature', 'Planeswalker', 'Battle', 'Instant',
            'Sorcery', 'Enchantment', 'Artifact', 'Land'
        ];
        const FONT_HEADING = '"Barlow Semi Condensed", sans-serif';
        const FONT_BODY = '"Open Sans", sans-serif';
        const CARD_W = 745;
        const CARD_H = 1040;
        const BORDER = 32;

        /* Packing list layout — base sizes are multiplied by scale factor S */
        const PACK = {
            CONTENT_PAD: 28,        // horizontal inset from card border
            TITLE_SIZE: 34,         // title font size (px)
            TITLE_BASELINE: 52,     // title Y from top border
            TITLE_RULE_GAP: 16,     // gap below title to horizontal rule
            FIRST_GROUP_GAP: 36,    // gap below rule to first group heading
            FOOTER_MARGIN: 40,      // reserved bottom space
            CELL_PAD: 14,           // horizontal padding inside each row
            NAME_SYM_GAP: 6,        // gap between card name and mana symbols
            BASE_ROW_H: 30,
            BASE_BODY_SIZE: 22,
            BASE_HEADING_SIZE: 28,
            BASE_HEADING_GAP: 10,   // heading text to underline
            BASE_UNDERLINE_GAP: 22, // underline to first card row
            BASE_GROUP_GAP: 12,     // space after last row before next group
            BASE_ROW_PAD: 8,        // vertical padding at top of each row
            BASE_SYM_PAD: 3,        // horizontal gap between mana symbols
            BASE_SYM_SIZE: 18,      // mana symbol size
        };

        /* Theme card overlay layout */
        const THEME = {
            ZONE_RATIO: 2 / 13,     // name bar & gradient each take 2/13 of inner height
            NAME_PAD: 60,            // horizontal padding for name text
            MIN_NAME_SIZE: 16,       // min font size when shrinking to fit
            NAME_SHRINK_STEP: 2,     // font size decrement per iteration
            SHADOW_OFFSET: 2,        // text shadow offset (px)
            SYM_SIZE: 40,            // mana symbol size
            SYM_GAP: 8,              // gap between mana symbols
            SYM_TOP_RATIO: 0.15,     // symbol Y position within gradient (0–1)
        };

        /* ===== DOM Refs ===== */
        const themeInput = document.getElementById('theme-name');
        const decklistEl = document.getElementById('decklist');
        const generateBtn = document.getElementById('generate-btn');
        const statusEl = document.getElementById('status');
        const colorToggles = document.querySelectorAll('.color-toggle');

        // Packing list
        const packingCanvas = document.getElementById('packing-canvas');
        const packingEdit = document.getElementById('packing-edit');
        const packingView = document.getElementById('packing-view');
        const packingEditBtn = document.getElementById('packing-edit-btn');
        const packingDownload = document.getElementById('packing-download');

        // Theme card
        const themeCanvas = document.getElementById('theme-canvas');
        const themeDownload = document.getElementById('theme-download');
        const themeDownloadRow = document.getElementById('theme-download-row');
        const themeControls = document.getElementById('theme-controls');
        const themeOverlay = document.getElementById('theme-overlay');
        const themeOverlayName = document.getElementById('theme-overlay-name');
        const themeOverlayColors = document.getElementById('theme-overlay-colors');
        const colorPickerSection = document.querySelector('.color-picker-section');

        /* ===== Packing Edit / View Toggle ===== */
        let lastPackingGroups = null;

        function showPackingView() {
            packingEdit.classList.add('hidden');
            packingView.classList.remove('hidden');
        }

        function showPackingEdit() {
            packingView.classList.add('hidden');
            packingEdit.classList.remove('hidden');
        }

        packingEditBtn.addEventListener('click', showPackingEdit);

        /* ===== Theme Name Input ===== */
        function updateThemeOverlay() {
            const text = themeInput.value.trim();
            themeOverlayName.textContent = text;

            if (!text) {
                // Use visibility (not .hidden) to preserve the name bar's layout
                // space within the overlay — collapsing it would misposition the gradient.
                themeOverlayName.style.visibility = 'hidden';
                themeOverlay.classList.add('no-name');
            } else {
                themeOverlayName.style.visibility = '';
                themeOverlay.classList.remove('no-name');
                // Size font to half the bar height, shrink if text overflows
                const barH = themeOverlayName.offsetHeight;
                shrinkFontToFit(Math.floor(barH / 2), 8, 1, s => {
                    themeOverlayName.style.fontSize = s + 'px';
                    return themeOverlayName.scrollWidth <= themeOverlayName.offsetWidth;
                });
            }
        }

        themeInput.addEventListener('input', async () => {
            updateThemeOverlay();
            if (!lastPackingGroups) return;
            if (!packingView.classList.contains('hidden')) {
                const title = themeInput.value.trim() || 'Packing List';
                await renderPackingList(lastPackingGroups, title);
                packingDownload.href = packingCanvas.toDataURL('image/png');
                packingDownload.download = slugify(themeInput.value.trim() || 'packing-list') + '-packing-list.png';
            }
        });

        /* ===== Color Identity State ===== */
        const selectedColors = new Set();

        colorToggles.forEach(btn => {
            btn.addEventListener('click', () => {
                const c = btn.dataset.color;
                if (selectedColors.has(c)) {
                    selectedColors.delete(c);
                    btn.classList.remove('active');
                } else {
                    selectedColors.add(c);
                    btn.classList.add('active');
                }
                updateColorOverlay();
            });
        });

        function setColorIdentity(colors) {
            selectedColors.clear();
            colorToggles.forEach(btn => btn.classList.remove('active'));
            for (const c of colors) {
                selectedColors.add(c);
                const btn = document.querySelector('.color-toggle[data-color="' + c + '"]');
                if (btn) btn.classList.add('active');
            }
            updateColorOverlay();
        }

        /* ===== Color Overlay Update ===== */
        function updateColorOverlay() {
            themeOverlayColors.replaceChildren();
            const colors = ['W', 'U', 'B', 'R', 'G'].filter(c => selectedColors.has(c));
            for (const c of colors) {
                const img = document.createElement('img');
                img.src = '/mtg/symbols/' + c + '.svg';
                img.alt = c;
                themeOverlayColors.appendChild(img);
            }
        }

        /* ===== Image Cropper ===== */
        class ImageCropper {
            constructor({ viewport, img, uploadZone, fileInput, cropArea, zoomSlider, changeImageBtn, onLoad, onError }) {
                this.viewport = viewport;
                this.img = img;
                this._uploadZone = uploadZone;
                this._fileInput = fileInput;
                this._cropArea = cropArea;
                this._slider = zoomSlider;
                this._onLoad = onLoad;
                this._onError = onError;

                this._natW = 0; this._natH = 0;
                this._vpW = 0; this._vpH = 0;
                this._minScale = 1; this._maxScale = 4;
                this._scale = 1;
                this._offX = 0; this._offY = 0;
                this._objectUrl = null;
                this.loaded = false;

                this._dragging = false;
                this._dragStartX = 0; this._dragStartY = 0;
                this._dragOffX = 0; this._dragOffY = 0;

                this._touches = [];
                this._pinchDist = 0; this._pinchScale = 0;
                this._pinchMidX = 0; this._pinchMidY = 0;
                this._pinchOffX = 0; this._pinchOffY = 0;

                this._onMouseMove = e => this._mouseMove(e);
                this._onMouseUp = () => { this._dragging = false; };
                this._bind(changeImageBtn);
            }

            _bind(changeImageBtn) {
                const uz = this._uploadZone;
                uz.addEventListener('click', () => this._fileInput.click());
                uz.addEventListener('dragover', e => { e.preventDefault(); uz.classList.add('drag-over'); });
                uz.addEventListener('dragleave', () => uz.classList.remove('drag-over'));
                uz.addEventListener('drop', e => {
                    e.preventDefault();
                    uz.classList.remove('drag-over');
                    const f = e.dataTransfer.files[0];
                    if (f && f.type.startsWith('image/')) this.load(f);
                });
                this._fileInput.addEventListener('change', () => {
                    if (this._fileInput.files[0]) this.load(this._fileInput.files[0]);
                });
                changeImageBtn.addEventListener('click', () => this._fileInput.click());

                this.viewport.addEventListener('mousedown', e => this._mouseDown(e));
                window.addEventListener('mousemove', this._onMouseMove);
                window.addEventListener('mouseup', this._onMouseUp);
                this.viewport.addEventListener('wheel', e => this._wheel(e), { passive: false });
                this.viewport.addEventListener('touchstart', e => this._touchStart(e), { passive: false });
                this.viewport.addEventListener('touchmove', e => this._touchMove(e), { passive: false });
                this.viewport.addEventListener('touchend', e => {
                    if (e.touches.length < 2) this._touches = [];
                    if (e.touches.length === 0) this._dragging = false;
                });
                this._slider.addEventListener('input', () => this._sliderInput());
            }

            load(file) {
                if (this._objectUrl) URL.revokeObjectURL(this._objectUrl);
                this._objectUrl = URL.createObjectURL(file);
                const tmp = new Image();
                tmp.onerror = () => { if (this._onError) this._onError(); };
                tmp.onload = () => {
                    this._natW = tmp.naturalWidth;
                    this._natH = tmp.naturalHeight;
                    this.img.src = this._objectUrl;
                    this._uploadZone.classList.add('hidden');
                    this._cropArea.classList.remove('hidden');
                    requestAnimationFrame(() => {
                        const r = this.viewport.getBoundingClientRect();
                        this._vpW = r.width;
                        this._vpH = r.height;
                        this._minScale = Math.max(this._vpW / this._natW, this._vpH / this._natH);
                        this._maxScale = this._minScale * 4;
                        this._scale = this._minScale;
                        this._offX = (this._vpW - this._natW * this._scale) / 2;
                        this._offY = (this._vpH - this._natH * this._scale) / 2;
                        this._slider.value = 0;
                        this.loaded = true;
                        this._applyTransform();
                        if (this._onLoad) this._onLoad();
                    });
                };
                tmp.src = this._objectUrl;
            }

            reset() {
                this._cropArea.classList.add('hidden');
                this._uploadZone.classList.remove('hidden');
                this._fileInput.value = '';
                this.img.src = '';
                if (this._objectUrl) { URL.revokeObjectURL(this._objectUrl); this._objectUrl = null; }
                this.loaded = false;
            }

            getCropRect() {
                const r = this.viewport.getBoundingClientRect();
                this._vpW = r.width;
                this._vpH = r.height;
                return {
                    srcX: -this._offX / this._scale,
                    srcY: -this._offY / this._scale,
                    srcW: this._vpW / this._scale,
                    srcH: this._vpH / this._scale
                };
            }

            _clamp() {
                const w = this._natW * this._scale, h = this._natH * this._scale;
                this._offX = Math.min(0, Math.max(this._vpW - w, this._offX));
                this._offY = Math.min(0, Math.max(this._vpH - h, this._offY));
            }

            _applyTransform() {
                this._clamp();
                this.img.style.transform =
                    'translate(' + this._offX + 'px,' + this._offY + 'px) scale(' + this._scale + ')';
            }

            _scaleToSlider(s) { return ((s - this._minScale) / (this._maxScale - this._minScale)) * 100; }
            _sliderToScale(v) { return this._minScale + (v / 100) * (this._maxScale - this._minScale); }

            _mouseDown(e) {
                if (e.button !== 0) return;
                this._dragging = true;
                this._dragStartX = e.clientX; this._dragStartY = e.clientY;
                this._dragOffX = this._offX; this._dragOffY = this._offY;
                e.preventDefault();
            }

            _mouseMove(e) {
                if (!this._dragging) return;
                this._offX = this._dragOffX + (e.clientX - this._dragStartX);
                this._offY = this._dragOffY + (e.clientY - this._dragStartY);
                this._applyTransform();
            }

            _wheel(e) {
                e.preventDefault();
                const r = this.viewport.getBoundingClientRect();
                const cx = e.clientX - r.left, cy = e.clientY - r.top;
                const old = this._scale;
                this._scale = Math.min(this._maxScale, Math.max(this._minScale,
                    this._scale * (e.deltaY > 0 ? 0.95 : 1.05)));
                this._offX = cx - (cx - this._offX) * (this._scale / old);
                this._offY = cy - (cy - this._offY) * (this._scale / old);
                this._slider.value = this._scaleToSlider(this._scale);
                this._applyTransform();
            }

            _touchStart(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    this._touches = Array.from(e.touches);
                    this._pinchDist = this._touchDist(this._touches);
                    this._pinchScale = this._scale;
                    const r = this.viewport.getBoundingClientRect();
                    this._pinchMidX = (this._touches[0].clientX + this._touches[1].clientX) / 2 - r.left;
                    this._pinchMidY = (this._touches[0].clientY + this._touches[1].clientY) / 2 - r.top;
                    this._pinchOffX = this._offX;
                    this._pinchOffY = this._offY;
                } else if (e.touches.length === 1) {
                    this._dragging = true;
                    this._dragStartX = e.touches[0].clientX; this._dragStartY = e.touches[0].clientY;
                    this._dragOffX = this._offX; this._dragOffY = this._offY;
                }
            }

            _touchMove(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const d = this._touchDist(Array.from(e.touches));
                    const ns = Math.min(this._maxScale, Math.max(this._minScale,
                        this._pinchScale * (d / this._pinchDist)));
                    this._offX = this._pinchMidX - (this._pinchMidX - this._pinchOffX) * (ns / this._pinchScale);
                    this._offY = this._pinchMidY - (this._pinchMidY - this._pinchOffY) * (ns / this._pinchScale);
                    this._scale = ns;
                    this._slider.value = this._scaleToSlider(this._scale);
                    this._applyTransform();
                } else if (e.touches.length === 1 && this._dragging) {
                    e.preventDefault();
                    this._offX = this._dragOffX + (e.touches[0].clientX - this._dragStartX);
                    this._offY = this._dragOffY + (e.touches[0].clientY - this._dragStartY);
                    this._applyTransform();
                }
            }

            _touchDist(t) { return Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY); }

            _sliderInput() {
                const old = this._scale;
                this._scale = this._sliderToScale(parseFloat(this._slider.value));
                const cx = this._vpW / 2, cy = this._vpH / 2;
                this._offX = cx - (cx - this._offX) * (this._scale / old);
                this._offY = cy - (cy - this._offY) * (this._scale / old);
                this._applyTransform();
            }
        }

        const cropper = new ImageCropper({
            viewport: document.getElementById('crop-viewport'),
            img: document.getElementById('crop-img'),
            uploadZone: document.getElementById('upload-zone'),
            fileInput: document.getElementById('file-input'),
            cropArea: document.getElementById('crop-area'),
            zoomSlider: document.getElementById('zoom-slider'),
            changeImageBtn: document.getElementById('change-image-btn'),
            onLoad() {
                themeControls.classList.remove('hidden');
                themeOverlay.classList.remove('hidden');
                colorPickerSection.classList.remove('hidden');
                themeDownloadRow.classList.remove('hidden');
                updateThemeOverlay();
            },
            onError() {
                showStatus('Failed to load image.', 'error');
            }
        });

        themeDownload.addEventListener('click', async (e) => {
            e.preventDefault();
            const themeName = themeInput.value.trim();
            await renderThemeCard(themeName || 'Theme');
            themeDownload.href = themeCanvas.toDataURL('image/png');
            themeDownload.download = slugify(themeName || 'theme-card') + '-theme-card.png';
            // Re-render then trigger download via a temporary <a> — the visible
            // download link's href is stale until clicked, so we render fresh here.
            const a = document.createElement('a');
            a.href = themeDownload.href;
            a.download = themeDownload.download;
            a.click();
        });

        /* ===== Mana Symbol Helpers ===== */
        const symbolCache = new Map();

        function loadSymbol(key) {
            if (symbolCache.has(key)) return symbolCache.get(key);
            const promise = new Promise(resolve => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => resolve(null);
                img.src = '/mtg/symbols/' + encodeURIComponent(key) + '.svg';
            });
            symbolCache.set(key, promise);
            return promise;
        }

        function parseManaCost(manaCost) {
            if (!manaCost) return [];
            return Array.from(manaCost.matchAll(/\{([^}]+)\}/g), m => m[1]);
        }

        async function resolveSymbols(keys) {
            await Promise.all(keys.map(s => loadSymbol(s)));
            const resolved = new Map();
            for (const k of keys) resolved.set(k, await symbolCache.get(k));
            return resolved;
        }

        async function preloadSymbols(groups) {
            const allSymbols = new Set();
            for (const [, cards] of groups) {
                for (const card of cards) {
                    for (const sym of parseManaCost(card.manaCost)) {
                        allSymbols.add(sym);
                    }
                }
            }
            return resolveSymbols([...allSymbols]);
        }

        /* ===== Decklist Parsing ===== */
        function parseDecklist(raw) {
            const lines = raw.split(/\r?\n/);
            const skipPattern = /^(\/\/|#|deck\b|sideboard\b|commander\b|companion\b|maybeboard\b)/i;
            const linePattern = /^(\d+)x?\s+(.+)$/;
            const consolidated = new Map();

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || skipPattern.test(trimmed)) continue;

                const match = trimmed.match(linePattern);
                let qty, name;

                if (match) {
                    qty = parseInt(match[1], 10);
                    name = match[2].trim();
                } else {
                    qty = 1;
                    name = trimmed;
                }

                // Strip trailing set code, collector number, foil markers
                // e.g. "Lightning Bolt (2XM) 117 *F*" → "Lightning Bolt"
                name = name
                    .replace(/\s*\*F\*\s*$/i, '')
                    .replace(/\s*[\(\[][A-Za-z0-9]+[\)\]]\s*\d*\s*$/, '')
                    .trim();

                if (!name) continue;
                // Consolidate duplicate names, preserving the first-seen casing
                const key = name.toLowerCase();
                consolidated.set(key, {
                    name: consolidated.has(key) ? consolidated.get(key).name : name,
                    qty: (consolidated.get(key)?.qty || 0) + qty
                });
            }

            return Array.from(consolidated.values());
        }

        /* ===== Scryfall Lookup (with color_identity) ===== */
        async function fetchCardTypes(cards) {
            const names = [...new Set(cards.map(c => c.name))];
            const BATCH_SIZE = 75; // Scryfall /cards/collection max per request
            const found = new Map();
            const notFound = [];
            const allColorIdentity = new Set();

            for (let i = 0; i < names.length; i += BATCH_SIZE) {
                if (i > 0) await sleep(100); // rate-limit between batches

                const batch = names.slice(i, i + BATCH_SIZE);
                const body = {
                    identifiers: batch.map(name => ({ name }))
                };

                const resp = await fetch('https://api.scryfall.com/cards/collection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!resp.ok) {
                    throw new Error('Scryfall API returned status ' + resp.status);
                }

                const data = await resp.json();

                if (data.data) {
                    for (const card of data.data) {
                        found.set(card.name.toLowerCase(), {
                            typeLine: card.type_line,
                            manaCost: card.mana_cost || ''
                        });
                        if (card.color_identity) {
                            for (const c of card.color_identity) {
                                allColorIdentity.add(c);
                            }
                        }
                    }
                }

                if (data.not_found) {
                    for (const nf of data.not_found) {
                        notFound.push(nf.name);
                    }
                }
            }

            return {
                found: cards.filter(c => found.has(c.name.toLowerCase())).map(c => {
                    const info = found.get(c.name.toLowerCase());
                    return { ...c, typeLine: info.typeLine, manaCost: info.manaCost };
                }),
                notFound,
                colorIdentity: allColorIdentity
            };
        }

        /* ===== Group by Type ===== */
        function groupByType(foundCards, notFoundNames, allCards) {
            const groups = new Map();

            for (const card of foundCards) {
                const type = extractPrimaryType(card.typeLine);
                if (!groups.has(type)) groups.set(type, []);
                groups.get(type).push(card);
            }

            for (const cards of groups.values()) {
                cards.sort((a, b) => a.name.localeCompare(b.name));
            }

            if (notFoundNames.length > 0) {
                const unknownCards = allCards.filter(c =>
                    notFoundNames.some(nf => nf.toLowerCase() === c.name.toLowerCase())
                );
                if (unknownCards.length > 0) {
                    groups.set('Unknown', unknownCards.map(c => ({ ...c, typeLine: 'Unknown', manaCost: '' })));
                }
            }

            const sorted = [];
            for (const type of TYPE_PRIORITY) {
                if (groups.has(type)) sorted.push([type, groups.get(type)]);
            }
            for (const [type, cards] of groups) {
                if (!TYPE_PRIORITY.includes(type) && type !== 'Unknown') {
                    sorted.push([type, cards]);
                }
            }
            if (groups.has('Unknown')) sorted.push(['Unknown', groups.get('Unknown')]);

            return sorted;
        }

        function extractPrimaryType(typeLine) {
            const face = typeLine.split('//')[0].trim();       // first face of double-faced cards
            const mainPart = face.split(/\u2014/)[0].trim(); // supertypes/types before the em-dash
            const words = mainPart.split(/\s+/);

            for (const type of TYPE_PRIORITY) {
                if (words.some(w => w.toLowerCase() === type.toLowerCase())) {
                    // "Artifact Creature" should list under Creature, not Artifact
                    if (type === 'Artifact' && words.some(w => w.toLowerCase() === 'creature')) {
                        continue;
                    }
                    return type;
                }
            }

            return 'Unknown';
        }

        /* ===== Render: Packing List ===== */
        // Find the largest scale multiplier (0–10 → 1.0×–2.0×) that fits all content on the card.
        function bestSizeOffset(groups) {
            const FOOTER_ZONE = CARD_H - BORDER - PACK.FOOTER_MARGIN;
            const BASE_Y = BORDER + PACK.TITLE_BASELINE + PACK.TITLE_RULE_GAP + PACK.FIRST_GROUP_GAP;
            let totalCards = 0;
            let totalGroups = 0;
            for (const [, cards] of groups) {
                totalCards += cards.length;
                totalGroups++;
            }
            for (let off = 10; off >= 0; off--) {
                const s = 1 + off * 0.1;
                const rowH = Math.round(PACK.BASE_ROW_H * s);
                const groupOverhead = Math.round(PACK.BASE_HEADING_GAP * s)
                    + Math.round(PACK.BASE_UNDERLINE_GAP * s)
                    + Math.round(PACK.BASE_GROUP_GAP * s);
                const y = BASE_Y + totalGroups * groupOverhead + totalCards * rowH;
                if (y <= FOOTER_ZONE) return off;
            }
            return 0;
        }

        async function renderPackingList(groups, title) {
            const ctx = packingCanvas.getContext('2d');

            await document.fonts.ready;
            const symbolMap = await preloadSymbols(groups);

            const sizeOffset = bestSizeOffset(groups);
            const S = 1 + sizeOffset * 0.1;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CARD_W, CARD_H);

            const innerW = CARD_W - BORDER * 2;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(BORDER, BORDER, innerW, CARD_H - BORDER * 2);

            const MARGIN_X = BORDER + PACK.CONTENT_PAD;
            const MAX_X = CARD_W - BORDER - PACK.CONTENT_PAD;
            const ROW_H = Math.round(PACK.BASE_ROW_H * S);
            const BODY_SIZE = Math.round(PACK.BASE_BODY_SIZE * S);
            const HEADING_SIZE = Math.round(PACK.BASE_HEADING_SIZE * S);
            const SYM_SIZE = Math.round(PACK.BASE_SYM_SIZE * S);
            const HEADING_GAP = Math.round(PACK.BASE_HEADING_GAP * S);
            const UNDERLINE_GAP = Math.round(PACK.BASE_UNDERLINE_GAP * S);
            const GROUP_GAP = Math.round(PACK.BASE_GROUP_GAP * S);
            const ROW_PAD = Math.round(PACK.BASE_ROW_PAD * S);
            const SYM_PAD = Math.round(PACK.BASE_SYM_PAD * S);
            let y = BORDER + PACK.TITLE_BASELINE;
            let overflow = false;
            const FOOTER_ZONE = CARD_H - BORDER - PACK.FOOTER_MARGIN;
            let rowIndex = 0;

            ctx.fillStyle = '#222222';
            ctx.font = 'bold ' + PACK.TITLE_SIZE + 'px ' + FONT_HEADING;
            ctx.textAlign = 'center';
            const truncTitle = truncateText(ctx, title.toUpperCase(), innerW - PACK.CONTENT_PAD * 2);
            ctx.fillText(truncTitle, CARD_W / 2, y);
            y += PACK.TITLE_RULE_GAP;

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(MARGIN_X, y);
            ctx.lineTo(MAX_X, y);
            ctx.stroke();
            y += PACK.FIRST_GROUP_GAP;

            ctx.textAlign = 'left';

            for (const [type, cards] of groups) {
                if (y > FOOTER_ZONE) { overflow = true; break; }

                const totalQty = cards.reduce((sum, c) => sum + c.qty, 0);

                ctx.fillStyle = '#e83411';
                ctx.font = 'bold ' + HEADING_SIZE + 'px ' + FONT_HEADING;
                const heading = type.toUpperCase() + ' (' + totalQty + ')';
                ctx.fillText(heading, MARGIN_X, y);
                y += HEADING_GAP;

                ctx.strokeStyle = '#e83411';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(MARGIN_X, y);
                ctx.lineTo(MAX_X, y);
                ctx.stroke();
                y += UNDERLINE_GAP;

                rowIndex = 0;
                for (const card of cards) {
                    if (y > FOOTER_ZONE) { overflow = true; break; }

                    const rowBg = rowIndex % 2 === 0 ? '#ecf1f6' : '#ffffff';
                    ctx.fillStyle = rowBg;
                    ctx.fillRect(MARGIN_X, y - ROW_H + ROW_PAD, MAX_X - MARGIN_X, ROW_H);
                    rowIndex++;

                    const symbols = parseManaCost(card.manaCost);
                    const symbolsWidth = symbols.length > 0
                        ? symbols.length * (SYM_SIZE + SYM_PAD) - SYM_PAD
                        : 0;

                    const qtyStr = card.qty + ' ';

                    ctx.font = 'bold ' + BODY_SIZE + 'px ' + FONT_BODY;
                    ctx.fillStyle = '#43484f';
                    ctx.fillText(qtyStr, MARGIN_X + PACK.CELL_PAD, y);
                    const qtyWidth = ctx.measureText(qtyStr).width;

                    ctx.font = BODY_SIZE + 'px ' + FONT_BODY;
                    ctx.fillStyle = '#43484f';
                    const nameX = MARGIN_X + PACK.CELL_PAD + qtyWidth;
                    const nameMaxWidth = MAX_X - PACK.CELL_PAD - nameX - symbolsWidth - (symbolsWidth > 0 ? PACK.NAME_SYM_GAP : 0);
                    const truncName = truncateText(ctx, card.name, nameMaxWidth);
                    ctx.fillText(truncName, nameX, y);

                    let symX = MAX_X - PACK.CELL_PAD - symbolsWidth;
                    for (const sym of symbols) {
                        const img = symbolMap.get(sym);
                        if (img) {
                            ctx.drawImage(img, symX, y - SYM_SIZE + SYM_PAD, SYM_SIZE, SYM_SIZE);
                        }
                        symX += SYM_SIZE + SYM_PAD;
                    }

                    y += ROW_H;
                }

                y += GROUP_GAP;
            }

            return overflow;
        }

        /* ===== Render: Theme Card ===== */
        async function renderThemeCard(themeName) {
            const ctx = themeCanvas.getContext('2d');
            await document.fonts.ready;

            const colors = ['W', 'U', 'B', 'R', 'G'].filter(c => selectedColors.has(c));
            const symbolMap = await resolveSymbols(colors);

            const { srcX, srcY, srcW, srcH } = cropper.getCropRect();

            ctx.clearRect(0, 0, CARD_W, CARD_H);
            ctx.drawImage(cropper.img, srcX, srcY, srcW, srcH, 0, 0, CARD_W, CARD_H);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CARD_W, BORDER);
            ctx.fillRect(0, CARD_H - BORDER, CARD_W, BORDER);
            ctx.fillRect(0, 0, BORDER, CARD_H);
            ctx.fillRect(CARD_W - BORDER, 0, BORDER, CARD_H);

            // --- Name bar + gradient layout (matches official theme cards) ---
            const innerH = CARD_H - BORDER * 2;
            const barH = Math.round(innerH * THEME.ZONE_RATIO);
            const gradH = barH; // both zones are 2/13
            const gradBottom = CARD_H - BORDER;
            const gradTop = gradBottom - gradH;
            const barTop = gradTop - barH;

            // Dark semi-transparent bar for theme name (only if name provided)
            const hasName = themeName && themeName.trim();
            if (hasName) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
                ctx.fillRect(BORDER, barTop, CARD_W - BORDER * 2, barH);
            }

            // Gradient zone below the bar — fade from transparent when no name
            // bar above, otherwise match the bar's opacity for a smooth transition.
            const grad = ctx.createLinearGradient(0, gradTop, 0, gradBottom);
            grad.addColorStop(0, hasName ? 'rgba(0, 0, 0, 0.45)' : 'rgba(0, 0, 0, 0)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0.85)');
            ctx.fillStyle = grad;
            ctx.fillRect(BORDER, gradTop, CARD_W - BORDER * 2, gradH);

            if (hasName) {
                // Theme name text centered in the bar (default = half bar height, shrink if needed)
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const barCenterY = barTop + barH / 2;
                const maxTextW = CARD_W - BORDER * 2 - THEME.NAME_PAD;

                const fontSize = shrinkFontToFit(Math.round(barH / 2), THEME.MIN_NAME_SIZE, THEME.NAME_SHRINK_STEP, s => {
                    ctx.font = 'bold ' + s + 'px ' + FONT_HEADING;
                    return ctx.measureText(themeName.toUpperCase()).width <= maxTextW;
                });

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillText(themeName.toUpperCase(), CARD_W / 2 + THEME.SHADOW_OFFSET, barCenterY + THEME.SHADOW_OFFSET);

                ctx.fillStyle = '#ffffff';
                ctx.fillText(themeName.toUpperCase(), CARD_W / 2, barCenterY);
            }

            // Mana symbols centered in the gradient zone
            if (colors.length > 0) {
                const totalSymW = colors.length * THEME.SYM_SIZE + (colors.length - 1) * THEME.SYM_GAP;
                let symX = (CARD_W - totalSymW) / 2;
                const symY = gradTop + Math.round(gradH * THEME.SYM_TOP_RATIO);

                for (const c of colors) {
                    const img = symbolMap.get(c);
                    if (img) {
                        ctx.drawImage(img, symX, symY, THEME.SYM_SIZE, THEME.SYM_SIZE);
                    }
                    symX += THEME.SYM_SIZE + THEME.SYM_GAP;
                }
            }
        }

        /* ===== Generate (main flow) ===== */
        generateBtn.addEventListener('click', run);

        async function generatePackingList(themeName) {
            const cards = parseDecklist(decklistEl.value.trim());
            if (cards.length === 0) {
                showStatus('No valid card lines found. Use format: "1x Card Name" or "1 Card Name".', 'error');
                return { error: true };
            }

            showStatus('Looking up card types...', 'info');
            const { found, notFound, colorIdentity } = await fetchCardTypes(cards);

            if (found.length === 0) {
                showStatus('None of the cards were found on Scryfall. Check spelling and try again.', 'error');
                return { error: true };
            }

            if (colorIdentity.size > 0) setColorIdentity(colorIdentity);

            if (notFound.length > 0) {
                showStatus(
                    'Warning: ' + notFound.length + ' card(s) not found: ' +
                    notFound.join(', ') + '. They will appear under "Unknown".',
                    'warning'
                );
            }

            const groups = groupByType(found, notFound, cards);
            lastPackingGroups = groups;

            showStatus('Rendering packing list...', 'info');
            const overflow = await renderPackingList(groups, themeName || 'Packing List');

            showPackingView();
            packingDownload.href = packingCanvas.toDataURL('image/png');
            packingDownload.download = slugify(themeName || 'packing-list') + '-packing-list.png';

            return { overflow };
        }

        async function generateThemeCard(themeName) {
            showStatus('Rendering theme card...', 'info');
            await renderThemeCard(themeName || 'Theme');

            themeDownloadRow.classList.remove('hidden');
            themeDownload.href = themeCanvas.toDataURL('image/png');
            themeDownload.download = slugify(themeName || 'theme-card') + '-theme-card.png';
        }

        async function run() {
            clearStatus();
            generateBtn.disabled = true;

            try {
                const hasDecklist = decklistEl.value.trim().length > 0;
                const hasImage = cropper.loaded;

                if (!hasDecklist && !hasImage) {
                    showStatus('Enter a decklist, upload an image, or both.', 'error');
                    return;
                }

                const themeName = themeInput.value.trim();
                let overflow = false;

                if (hasDecklist) {
                    const result = await generatePackingList(themeName);
                    if (result.error) return;
                    overflow = result.overflow;
                }

                if (hasImage) {
                    await generateThemeCard(themeName);
                }

                if (overflow) {
                    showStatus('List too long for card — some entries were cut off.', 'warning');
                } else {
                    clearStatus();
                }
            } catch (err) {
                showStatus('Error: ' + (err.message || 'Something went wrong.'), 'error');
            } finally {
                generateBtn.disabled = false;
            }
        }

        /* ===== Helpers ===== */
        function slugify(text) {
            return text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        }

        function shrinkFontToFit(startSize, minSize, step, fits) {
            let size = startSize;
            while (size > minSize && !fits(size)) size -= step;
            return size;
        }

        function truncateText(ctx, text, maxWidth) {
            if (ctx.measureText(text).width <= maxWidth) return text;
            let truncated = text;
            while (truncated.length > 0 && ctx.measureText(truncated + '...').width > maxWidth) {
                truncated = truncated.slice(0, -1);
            }
            return truncated + '...';
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function showStatus(msg, type) {
            statusEl.textContent = msg;
            statusEl.className = 'status status--' + type;
        }

        function clearStatus() {
            statusEl.textContent = '';
            statusEl.className = 'status';
        }
    </script>
</body>
</html>
